data = [
    ['נתון מערך A המכיל n מספרים שלמים.  בהינתן מספרx  המופיע ב A, נגדיר את הריבוי שלx  במערך A בתור מספר המופעים של x ב-A. רוצים לייצר מערך ממוין B בגודל n, שיכיל את הריבוי של כל אחד מהמספרים המופיעים ב A. \n\nהציעו אלגוריתם שפותר את הבעיה בתוחלת זמן הטובה ביותר.', 'תאור האלגוריתם:\nנכניס את איברי הקבוצה לטבלת Hash בגודל (n).  ערכים חוזרים יוחזקו על ידי מונה (כלומר בפעולת ההכנסה, נעבור על כל הרשימה בתא אליו הגענו, ורק אם הערך לא נמצא נוסיף איבר חדש לרשימה, עם מונה מאותחל לאחד). בסוף הכנסת כל האיברים, נעבור על הטבלא ונחלץ את כל הריבויים. כל הערכים הנ"ל הם שלמים בתחום 1 עד n לכן ניתן למינם בעזרת CountSort. הוכחת זמן ריצה :\nהכנסה לטבלה – סה"כ צפוי  (ממוצע) O(n)\nחילוץ ריבויים מהטבלה O(n) \nCountSort O(n)\n\nסה"כ צפוי O(n)'],
    ['בהינתן שני מערכים A ו B, כל אחד בגודל n, מעוניינים לייצר מערך שלישי C בגודל n,  בעל התכונה הבאה: הערך הרשום ב C[i] שווה מספר איברי A הקטנים מ B[i].\nתארו אלגוריתם בעל סיבוכיות ה W.C. הטובה ביותר לפתרון הבעיה.', 'תיאור האלגוריתם:\nנמיין את A בעזרת HeapSort.\nעבור כל איבר ב-B נמצא כמה איברים קטנים ממנו בעזרת חיפוש בינארי ב O(lg n). \nחשוב מאוד: אם ב-A  יש איברים המופיעים יותר מפעם אחת, חיפוש בינארי רגיל לא יעבוד. לכן בכל דגימה של ערך, אם הערך הנדגם שווה לערך שמחפשים האלגוריתם לא יעצור אלא יבצע קריאה רקורסיבית על החצי השמאלי (שמכיל את האיברים הקטנים יותר.  הוכחת זמן ריצה:\nמיון: (n lg n)\nn חיפושים בינארים  (n lg n)\nסה"כ (n lg n)\n'],
    ['נתונים n  מפתחות שונים זה מזה וממוינים.  תארו מבנה נתונים יעיל  המתחזק מפתחות אלו (הניחו שהמבנה כבר בנוי, כלומר לא חשובה עלות בנייתו) והתומך בפעולת find_delete(key)המקבלת מפתח והמחזירה  false  אם המפתח אינו במבנה. אם הוא במבנה, הפעולה מחזירה true  ומוציאה אותו מהמבנה.    עלות נדרשת: O(log n) לפעולת find_delete(key).', 'תאור המבנה:\nעץ חיפוש מאוזן.\n\n\nסבוכיות הפעולה – הסבירו: \nמציאת איבר בעץ, וכן מחיקתו עולות O(logn).'],
    ['תאר אלגוריתם הפותר את הבעיה הבאה: בהינתן קבוצה S של n מספרים, האלגוריתם בונה בזמן  ,W.C. O(n) מבנה נתונים התומך בפעולה find בלבד, באופן ש: זמן ה W.C של find הוא O(n), אולם על לפחות n/log n מהאיברים, זמן הריצה של find הוא O(log n). שימו לב כי המבנה אינו דינאמי, כלומר אינו צריך לתמוך ב insert ו delete.', 'תיאור האלגוריתם והוכחת נכונות:\nלוקחים n/log n  איברים  ומכניסים לעץ חפוש מאוזן (למשל 2-3)  או למערך ממוין. עלות כוללת  היא O(n). שאר האיברים מוכנסים לרשימה.\n\nבעת בצוע find  מחפשים קודם בעץ ואחר כך ברשימה. עלות חפוש על כל אבר בעץ היא O(log n). שאר האיברים – O(n).'],
    ['רוצים אלגוריתם יעיל ככל הניתן לבעיה הבאה:\nקלט: n קטעים על הישר (כלומר n זוגות של נקודות התחלה וסיום).\nשאלה: האם יש שלושה  קטעים בקלט שיש להם לפחות נקודת חיתוך אחת משותפת?', 'תאור האלגוריתם וניתוח זמן ריצה:\nבונים מערך שמכיל את כל נקודות הקצה של כל הקטעים. מסמנים לכל נקודה אם היא הייתה נקודת התחלה או נקודת סיום. ראשית, ממיינים את המערך כך שהנקודות יהיו מסודרות משמאל לימין. אם יש "תיקו", כלומר נקודות שוות, אז שמים במערך את נקודות ההתחלה לפני נקודות הסיום. שנית, סורקים את המערך, ובכל שלב שומרים את מס\' נקודות ההתחלה שעברנו פחות מס\' נקודות הסיום שעברנו, פשוט ע"י הפחתה של 1 ממונה כשעוברים נק\' סיום, והוספה של 1 בנק\' התחלה. קל לראות שהמונה שווה בדיוק למס\' הקטעים שהנק\' הנוכחית נמצאת בהם, קל גם לראות שאם יש 3 קטעים שיש להם נקודה משותפת, אזי יש נקודה כזאת שהיא בפרט נק\' קצה של קטע. לכן צריך להחזיר \'כן\' אם ורק אם המונה מגיע באיזשהו שלב לערך שהוא לפחות 3. המיון לוקח זמן O(nlogn) והמעבר לוקח זמן לינארי, אז סה"כ זמן O(nlogn).\n\nטעויות נפוצות: 1. היו פתרונות שמיינו את הקטעים לפי נק\' התחלה, ואז בדקו אם ישנם שלושה קטעים סמוכים במערך שנחתכו באותה נקודה. זהו פתרון שגוי מכיוון שיכול להיות שיש שלשת קטעים שנחתכים באותה נק\' בעוד שאין שלשה כזו של קטעים עם נק\' התחלה שמוכות. למשל כמו בדוגמה הבאה:\n\n\n\n\n\n2. היו גם פתרונות שבדקו רק אם יש שלשת קטעיםעוקבים שבה הראשון נחתך עם השני והשני נחתך עם השלישי, אך לא בדקו ששלושתם נחתכים בנקודה אחת. '],
    ['תארו מבנה נתונים המתחזק קבוצה של נקודות במישור, כאשר כל נקודה  piמיוצגת כזוג מספרים (xi,yi). מבנה הנתונים צריך לתמוך בפעולות insert(x,y), delete(x,y), find(x,y) בזמן גרוע ביותר O(log n), וכמו כן תומך בפעולה  CountPointsAtDistance(d1,d2), המבצעת את הפעולה הבאה: בהינתן שני מספרים d1,d2 מחזירה הפעולה את מספר הנקודות במבנה שמרחקן מהראשית גדול מ d1 וקטן מ d2 (זיכרו כי מרחק נקודה (x,y) מהראשית הוא (x^2 + y^2)^0.5).  \nCountPointsAtDistance(d1,d2)  צריכה להתבצע בסיבוכיות הנמוכה ביותר האפשרית.', 'עץ חיפוש מאוזן (2-3  או AVL למשל) שבו המפתח הינו המרחק d. מתחת לכל עלה מוחזק עץ 2-3 שבו המפתחות המתאימים  (x,y) בסדר לקסיקוגרפי. \nהעץ הראשי בנוי כעץ ORDER STAT בו בכל צומת שומרים את מספר המפתחות שנמצאים בתת העץ. כיצד ממומשת הפעולה CountPointsAtDistance ומה הסיבוכיות שלה:\nמוצאים את הנקודה הרחוקה ביותר מהראשית שמרחקה קטן מ-d2.\nמחשבית את הסדר הסטטיסטי שלה: a. \nמוצאים את הנקודה הקרובה ביותר לראשית שמרחקה גדול מ-d2.\nמחשבית את הסדר הסטטיסטי שלה: b. \nמחזירים את a-b+1.\nכל אחת מהפעולות הנ"ל מבוצעת בזמן O(log n) W.C. לכן זהו זמן ריצת הפעולה.'],
    ['תארו אלגוריתם לפתרון הבעיה הבאה: \nקלט: קבוצה כלשהי {a1,...,an}=A של n מספרים. \nמטרה: האלגוריתם צריך לבנות בזמן ממוצע טוב ביותר מבנה נתונים DS בעל התכונה הבאה:             בהינתן אוסף S של m מספרים שאיבריו לקוחים מ A, ניתן להיעזר בDS  בכדי למיין את איברי S בזמן  O(max(m,n)) ב WC. שימו לב כי S יכולה להכיל איבר כלשהו של A מספר פעמים. על כן ייתכן כי מתקיים m>n.', 'תאור מבנה הנתונים DS:\nPerfect hash של האיברים עבור ערכם. לכל איבר שומרים גם את הrank  שלו (הסדר הסטטיסטי). \nתאור בניית המבנה:\nממינים המערך –O(nlgn) – למציאת rank  של כל איבר. \nמכניסים את האיברים לperfecct hash O(n)בממוצע. \n\n\n\nכיצד ניתן למיין בעזרת מבנה הנתונים:\nמוצאים את הסדר הסטטיסטי של כל איבר ב-S. ממינים את S לפי הסדרים הסטטיסטים בעזרת CountSort.\n'],
    ['בשאלה זו נעסוק באלגוריתם מיון Quicksort. לכל אורך השאלה נניח שהקלט הוא מערך באורך n, ונתעניין רק במערכים בהם כל האיברים שונים. כזכור, לכל אלגוריתם מיון מתאים עץ בינארי המתאר את ההשוואות שהאלגוריתם מבצע על כל הקלטים האפשריים.\n\nנתעניין באלגוריתם המיון QuickSort כאשר איבר הציר (Pivot) נבחר להיות הראשון בקטע המערך עליו האלגוריתם פועל (ולא נבחר על ידי הגרלה), ובעץ ההשוואות המתאים.\n\nא. מהו העומק הקטן ביותר של עלה בעץ השוואות זה כפונקציה של n?', "תשובה והסבר: O(nlogn), מאותה סיבה ש-quicksort הרגיל דורש O(nlogn) השוואות. במקרה הכי טוב מתבצעת חלוקה של המערך לשני חלקים בגודל O(n), ועדיין יהיו O(log n) שלבים, ומס' ההשוואות בכל שלב הוא O(n). \n"],
    ['תאר מימוש לפעולה DeleteMin בערימה (Heap) הממומשת כמו שתיארנו בכתה שמבצע  O(log(n)^0.5) השוואות במקרה הגרוע ביותר, או הוכח כי אין מימוש כזה.', 'אין מימוש כזה. אחרת היה אפשר למיין n איברים במודל ההשוואות בזמן o(nlogn) בניגוד למה שהוכחנו בכיתה. זאת על ידי בניית ערימה בזמן לינארי (כפי שלמדנו) ואז קריאה ל-DeleteMin n פעמים, והדפסת האיבר המתקבל בכל פעם. '],
    ['נתונים n קטעים על הישר (כל קטע נתון על ידי נקודות התחלה וסיום). לשם פשטות, נניח שכל 2n הנקודות שונות זו מזו.\nקטע יקרא "מרכזי" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו אלגוריתם שמחזיר את מספר הקטעים המרכזיים, בזמן ריצה worst-case הטוב ביותר שתוכלו.', 'אלגוריתם: זמן ריצה O(n).\nמצא את האיבר ה-n/4 בגודלו מבין נקודות ההתחלה, נקרא לו a.\nמצא את האיבר ה-n/4 בגודלו מבין נקודות הסיום, נקרא לו b.\nסרוק את הקטעים בזה אחר זה וספור כמה מתחילים אחרי a ומסתיימים לפני b.\nניתוח זמן ריצה: מציאת האיבר ה-i בגודלו הוא O(n) בעזרת Select. הסריקה לוקחת O(n) כי כל בדיקה לוקחת שתי השוואות, כלומר  O(1).\n'],
    ['נתונים n קטעים על הישר (כל קטע נתון על ידי נקודות התחלה וסיום). לשם פשטות, נניח שכל 2n הנקודות שונות זו מזו.\nקטע יקרא "מרכזי" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו מבנה נתונים דינמי, המאפשר Insert ו-Delete של קטעים על הישר בזמן O(log n) במקרה הגרוע וכן תומך בפעולה IsCentric(p) שמקבלת מצביע לקטע במבנה, ועונה האם הקטע הוא מרכזי, בזמן O(1) במקרה הגרוע.', 'תאור המבנה: \nעץ מאוזן שמכיל את כל נקודות ההתחלה, ומשמש גם למציאת order-statistic כפי שנלמד בכיתה, ע" שמירת כמות הצאצאים של כל צומת. \nעץ נוסף כזה המכיל את נקודות הסיום. \nבעץ של נקודות ההתחלה יהיה מצביע p1 לצומת המייצג את האיבר ה-n/4 בגודלו\nבעץ של נקודות הסיום יהיה מצביע p2 לצומת המייצג את האיבר ה-3n/4 בגודלו מימוש פעולת Insert וניתוח זמן ריצה:\nמכניסים את נקודת ההתחלה של הקטע לעץ הראשון, ומעדכנים את כמות הצאצאים בכל צומת כפי שלמדנו בכיתה.\nבנוסף, מחפשים את האיבר ה-n/4 בגודלו בעץ ומעדכנים את המצביע p1.\nכנ"ל עבור נקודת הסיום והעץ השני, עם מצביע p2.\nההכנסה לעץ os לוקחת O(logn) כפי שנלמד בכיתה, ואותו זמן לוקח למצוא את האיבר המתאים.\nסה"כ: 2*2*O(logn)=O(logn) זמן ריצה.\nמימוש פעולת Delete וניתוח זמן ריצה: בדומה ל- Insert, מוחקים את ערך נקודת ההתחלה מהעץ הראשון, ומעדכנים את p1. באופן דומה עבור העץ השני.\nמימוש פעולת IsCentric וניתוח זמן ריצה: \nבודקים אם ערך נקודת ההתחלה של הקטע הנתון גדול מ-p1 וקטן מ-p2. זמן: O(1), כי בסה"כ מבצעים 2 השוואות.\n'],
    ['נתונה ערימת מינימום, ללא מפתחות כפולים.\nלכל צומת x יש שדה נוסף s, שמאותחל ל-nil. רוצים שהשדה s של כל צומת x יכיל מצביע לעוקב  של x. הניחו שיש גישה לאברי הערימה (כלומר הערימה לא קופסה שחורה). אין לשנות את מבנה הערימה. הציעו אלגוריתם שמבצע את הנ"ל בזמן כולל W.C. כמה שיותר טוב, אם נתון שהמפתחות הם שלמים בתחום 1 עד 2n  . ', 'תיאור האלגוריתם:\nI. נסרוק את הערימה (למשל DLR) ונעתיק את המפתחות למערך עזר. נזכור לכל מפתח מצביע למקומו המקורי בערימה.\nII. נמיין את המערך על ידי שימוש באלגוריתם\n\n מיון בזמן לינארי, למשל  CountSort\n (או BinSort).\nIII. נסרוק את המערך משמאל לימין, ולכל איבר ניגש (בעזרת המצביע) לצומת המתאים לו בערימה ונעדכן את השדה s שיכיל את המצביע שבאיבר הבא במערך.'],
    ['בB-trees- עם דרגה מינימאלית d (לכל צומת פנימי בין d ל-2d ילדים) כמות המידע הנשמרת בעלים קטנה יותר מכיוון שאין צורך לשמור שם מצביעים לילדים. נניח ש- block על הדיסק גדול מספיק להכיל צומת בגודל מקסימאלי ושכל צומת מאוכסן ב-block נפרד על הדיסק.\nעל מנת לנצל את המקום הפנוי ב-block disk המכיל עלה נשנה את הגדרת העץ ונקבע שבכל עלה יהיו בין 2d-1 ל-4d-1 אלמנטים במקום בין d-1 ל-2d-1. נתון שגודל אלמנט הוא כגודל מצביע, ולכן עלה מוגדל כזה עדיין נכנס ב-block. כל עוד אין בעץ יותר מ-4d אלמנטים העץ מורכב מעלה מוגדל בודד.\nנקרא לעץ כזה עץ B-tree עם עלים מוגדלים. תאר בקצרה אלגוריתם להכנסה top-down (האלגוריתם לא משנה את העץ לאחר הכנסת האיבר לעלה המתאים אלא רק תוך כדי החיפוש) ל-B-tree עם עלים מוגדלים כמתואר לעיל.', 'מחפשים את מיקום האיבר החדש בעץ החל מהשורש. בכל פעם שיורדים בדרך לצומת מלאה (צומת המכיל 2d בנים) מפצלים אותו, כך שלא תיווצר שרשרת פיצולים כאשר נגיע לעלה. כאשר מגיעים\nלעלה מכניסים את האיבר כרגיל, בשלב זה עשוי להיגרם פיצול אחד לכל היותר.'],
    ['הכניסו קבוצת איברים X1 בגודל n1 לטבלת hashing בגודל m שמשתמשת בשיטת ה-chaining תוך שימוש בפונקצית hashing h. כל הרשימות המקושרות שהתקבלו היו באורך של לכל היותר k1. הכניסו עתה קבוצת איברים שניה X2 בגודל n2 לטבלת hashing אחרת בגודל m שמשתמשת אף היא בשיטת ה-chaining תוך שימוש באותה פונקצית hashing h. כל הרשימות המקושרות שהתקבלו היו באורך של לכל היותר k2. לבסוף הכניסו את כל איברי X1 ו-X2, בסדר כלשהו, לטבלת hashing שלישית בגודל m, שוב תוך שימוש בשיטת ה-chaining ועם אותה פונקציה h. תן/י חסם, לא אסימפטוטי, טוב ככל האפשר על מספר המפתחות שיבחנו בעת פעולת חיפוש (מוצלח או לא מוצלח) בטבלת ה-hashing השלישית. נמק/י.', 'מספר המפתחות שיבחנו בעת פעולת חיפוש הוא בדיוק אורך הרשימה.\nברשימה אחת יהיו לכל היותר k1+k2 איברים, לכן זהו המספר המקסימלי של מפתחות שייבחנו בעת חיפוש כלשהו.'],
    ['נתון גרף מכוון. הגרף מוגדר על-ידי קבוצה של n צמתים ו-m קשתות. כל קשת היא זוג סדור של צמתים. הקשתות היוצאות מכל צומת מאוכסנות ברשימה מקושרת (singly linked list).\n\nכל צומת v מיוצג על ידי אובייקט שעליו ניתן לעשות את הפעולות הבאות בלבד:\nedges(v): מחזירה את רשימת הקשתות שיוצאות מ-v.\nנניח כי בגרף n צמתים שכל אחד מזוהה על ידי מספר שלם בין 1 ל-n. הפעולה id(v) מחזירה את המספר המתאים לצומת v.\nהגרף כולו מיוצג על ידי מערך בגודל n בו התא id(v) מצביע לאובייקט המייצג את צומת v.\n\nעל רשימת קשתות L (היוצאות מצומת מסוים) ניתן לבצע את הפעולות הבאות בלבד:\nfirst(L): מחזירה את הקשת הראשונה ברשימה.\ndelete-first(L): מסירה את הקשת הראשונה ברשימה.\ninsert-first(L,e): מכניסה אובייקט המייצג קשת e בתחילת רשימת הקשתות L.\nlength(L): מחזירה את אורך הרשימה L.\nכל קשת e=(v,w) מיוצגת על ידי אובייקט שעליו ניתן לבצע את הפעולות הבאות בלבד:\nnext(e): מחזיר את הקשת העוקבת ל-e ברשימת הקשתות היוצאות מ-v.\ndelete-after(e): מסיר את הקשת שאחרי e ברשימת הקשתות שיוצאות מ-v.\nsource(e): מחזיר את הצומת v ממנו יוצאת e.\ntarget(e): מחזיר את הצומת v אליו נכנסת e.\nהפעולות שהוגדרו הן הפעולות היחידות שניתן לעשות על האובייקטים השונים המייצגים את הגרף.\n\nלצורך ניתוח האלגוריתמים נסמן ב-d(v) את מספר הקשתות שיוצאות מ-v.\n\nא. בהינתן שני צמתים v ו-w תאר אלגוריתם יעיל ככל שתוכל שבודק האם יש קשת מ-v ל-w. מה זמן הריצה של האלגוריתם?', 'עוברים על רשימת הקשתים שיוצאות מ-v ובודקים אם יש קשת (v,w). זמן ריצה O(d(v)).'],
    ['תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) התומך בפעולות הבאות:\ninsert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). ניתן להניח שהזוג מופיע במבנה הנתונים. על הפעולה להתבצע בזמן O(1) בתוחלת.\nSearchAll(a) – החזר רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי בהם. על הפעולה להתבצע בזמן O(1) בתוחלת.', 'נממש את מבנה הנתונים ע"י hash על המפתח השמאלי a כאשר כל תא בטבלת ה-hash מחזיק רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי שלהם. insert יכניס את האיבר לתחילת הרשימה ו-SearchAll יחזיר את כל הרשימה.'],
    ['נתונים n זוגות של מפתחות (a1,b1), (a2,b2),…, (an,bn), כך שכל מפתח ai וכל מפתח bj (עבור 1≤i,j≤n) הם מספרים שלמים מהתחום [1,10n]. תאר/י מבנה נתונים שניתן לבנות בזמן Worst case O(n) (בהינתן n זוגות המפתחות) ותומך בפעולה הבאה בזמן Worst case O(1):\nSearchAll(a) – החזר רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי בהם.', 'נאתחל טבלה עם 10n תאים, כך שהתא ה – i חזיק רשימה של כל זוגות המפתחות ש – i הוא המפתח השמאלי שלהם.'],
    ['תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) כך שכל מפתח שמאלי בזוג הוא מספר שלם שייך לתחום [1,10n]. ניתן להניח שכל זוגות המפתחות שונים זה מזה. על מבנה הנתונים לתמוך בפעולות הבאות (כאשר n הוא מספר זוגות המפתחות שנמצאים כרגע במבנה הנתונים):\nInsert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). על הפעולה להתבצע בזמן אמורטייזד של O(1).\nIncreaseKey((a,b),x) – הפקודה מקבלת מצביע לזוג מפתחות (a,b) שנמצא במבנה הנתונים ומספר חיובי x ומגדילה את המפתח הימני ב-x. על הפעולה להתבצע בזמן אמורטייזד של O(1).\nDelete((a,b)) - הפקודה מקבלת מצביע לזוג מפתחות (a,b) שנמצא במבנה הנתונים ומוחקת אותו. על הפעולה להתבצע בזמן אמורטייזד של O(logn).', 'נממש ע"י מערך כשכל תא מצביע לערימת מקסימום. בכל הפעולות ניגש לתא ה-a במערך ונפעיל את הפקודה המתאימה בערימה עם מפתח b.'],
    ['תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) התומך בפעולות הבאות (כאשר n הוא מספר זוגות המפתחות שנמצאים כרגע במבנה הנתונים וניתן להניח שכל זוגות המפתחות שונים זה מזה):\nInsert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). על הפעולה להתבצע בזמן O(logn).\nDelete(a,b) – מחק את זוג המפתחות (a,b). על הפעולה להתבצע בזמן O(logn).\nSearch(a,b) – החזר את זוג המפתחות (a,b) אם קיים, אחרת החזר null. על הפעולה להתבצע בזמן O(logn).\nsuccessor(a,b) – החזר את (a,b*) כך ש-b* מוגדר באופן הבא: יהיו b1,b2,b3,…,bm כל המפתחות כך שהזוג (a,bi) נמצא במבנה הנתונים (עבור 1≤i≤m) ממויינים מהקטן לגדול. אזי b* הוא המפתח שנמצא מימינו של b ברשימה הממויינת. במידה ואין מפתח מימינו של b ברשימה הממויינת החזר null. על הפעולה להתבצע בזמן O(logn).', 'נממש ע"י עץ אדום שחור שכל צומת בו מצביע לעץ אדום שחור. בכל הפעולות נחפש על העץ הראשי לפי a ועל העץ המשני (עץ שמוצבע מצומת בעץ הראשי) לפי b.'],
    ['תאר/י מבנה נתונים התומך בפעולות הבאות (כאשר n הוא מספר המפתחות שנמצאים כרגע במבנה הנתונים וניתן להניח שכל המפתחות שונים זה מזה):\nInsert(a) – הוסף למבנה הנתונים את המפתח a. על הפעולה להתבצע בזמן O(logn).\nDelete(a) – מחק את המפתח a. על הפעולה להתבצע בזמן O(logn).\nSearch(a) – החזר את המפתח a אם קיים, אחרת החזר null. על הפעולה להתבצע בזמן O(logn).\nSum(a) – החזר את סכום כל המפתחות שקטנים מ-a. ניתן להניח ש-a קיים במבנה הנתונים. על הפעולה להתבצע בזמן O(logn).', 'נממש ע"י עץ אדום שחור שבו כל צומת שומר את סכום המפתחות של תת העץ שהוא שורשו. פעולת Sum תתבצע ע"י ירידה מהשורש ל-a וסכימת שדות הסכום של כל הבנים השמאליים של הצמתים לאורך המסלול ביחד עם שדה הסכום של a.'],
    ['נתונה קבוצה סדורה S. נגדיר דרגה של איבר בקבוצה מסוימת כמקום הופעתו במערך ממוין של האיברים (כל האיברים בעלי ערכים שונים). לאורך השאלה ח מסמן את מספר האיברים הנוכחי במבנה הנתונים המבוקש.\n\nא. תארו מבנה נתונים התומך בפעולות הבאות:\n• Init() – אתחול המבנה בזמן O(1).\n• Insert(x) – הכנסת האיבר x ל-S בזמן O(logn).\n• Delete(x) – מחיקת האיבר x מ-S בזמן O(logn).\n• Min() – החזרת האיבר בעל הדרגה המינימלית בגודלו בזמן O(1).\n• Max() – החזרת האיבר בעל הדרגה מקסימלית בגודלו בזמן O(1).\n• AVG() – החזרת האיבר בעל הדרגה המינימלית שערכו גדול או שווה לממוצע האיברים במבנה בזמן O(1).\n\n', 'נשתמש בעץ בינארי מאוזן בעל שדות עזר שמתעדכן בכל פעולת insert/delete: מצביעים לאיברים המינימלי והמקסימלי (נמצא אותם ע"י הליכה רק שמאלה או ימינה מהשורש עד לעלה), מצביע לאיבר המינימלי הגדול או שווה מהממוצע, מספר האיברים בעץ וסכום האיברים בעץ. \nעל מנת לתחזק את המצביע לאיבר הממוצע, בעת הכנסה נעדכן השדות של מספר האיברים וסכומים, נחשב הממוצע ונמצא באמצעות חיפוש את האיבר הכי קרוב אליו מלמעלה. בדומה עבור פעולת delete. \nבעת קריאה ל-Min/Max/AVG נחזיר את האיבר לפי המצביע המתאים.'],
    ['נתון מערך של 𝑛 מספרים. בכל השאלות נרצה למצוא איבר החוזר מספר מסוים של פעמים במערך. במידה וקיים יותר מאיבר אחד כזה, אזי יש להחזיר אחד מהם.\nהציעו אלגוריתם למציאת האיבר החוזר בכל אחד מהמקרים הבאים:\n\nא. ידוע שקיים איבר שחוזר לפחות 𝐿 פעמים. בסעיף זה ניתן להשתמש ברנדומיות.\n', 'נתחזק טבלת Hash בה ה-key הוא המספר והערך הינו מונה. נעבור על מערך הקלט ונספור חזרות של כל איבר. נעבור שוב ונחזיר איבר שערך המונה שלו לפחות 𝐿. סיבוכיות O(𝑛) בתוחלת.'],
    ['נתון מערך עם n מספרים.\nתאר/י אלגוריתם בסיבוכיות O(n) שבודק האם יש איבר שמופיע לפחות n/8 פעמים במערך. הוכח/י את תשובתך.', 'נבצע select על האיברים במקום n/9,  2n/9,  3n/9,  4n/9,  5n/9,  6n/9,  7n/9,  8n/9. כעת נעבור על המערך ונבדוק אם אחד מ – 8 המועמדים מופיע לפחות n/8 פעמים.'],
    ['נתון מערך עם n מספרים.\nב.\tתאר/י אלגוריתם דטרמניסטי בסיבוכיות O(nlogn) שמחזיר את מספר האיברים השונים במערך. הוכח/י את תשובתך.', 'נמיין את המערך ע"י merge sort. כעת נעבור על המערך הממויין ובכל פעם שניתקל באיבר ששונה מהאיבר שלפניו נגדיל מונה ב – 1.'],
    ['נתון אוסף של קבוצות s_1,s_2,…,s_m.\nתאר/י מבנה נתונים התומך בפעולות הבאות:\nMakeItem(i) \uf0ac A – צור את האיבר A שמחזיק את המספר i\nInsert(j,A) – הכנס את האיבר A לקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).\nDelete(j,A) – מחק את האיבר A מקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).\nFindMin(j) – החזר את האיבר המינימלי בקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).\nCreateSet(j,Arr) – בנה את הקבוצה j מתוך מערך לא ממויין של מספרים.\nFindMin() – החזר את האיבר המינימלי מבין כל האיברים בקבוצות s_1,s_2,…,s_m.\nעל כל הפעולות מלבד CreateSet לרוץ בסיבוכיות O(logn) כאשר n הוא מספר האיברים הכולל בקבוצות s_1,s_2,…,s_m. על CreateSet לרוץ בסיבוכיות ליניארית בגודל מערך הקלט.', 'נחזיק ערימת מינימום לכל קבוצה ובנוסף ערימת מינימום שבה יוחזקו ערך המינימום של כל אחת מהקבוצות Delete(j,A) ,CreateSet(j,arr) , Insert(j,A)  יעדכנו את ערימת המינימום של קבוצה s_j ואם איבר המינימום שלו התעדכן גם את ערימת המינימום של כל הקבוצות. FindMin(j) יחזיר את איבר המינימום מהערימה המתאימה לקבוצה s_j. FindMin() יחזיר את איבר המינימום מהערימה של כל הקבוצות.'],
    ['נתון מערך של ח מספרים שלמים בין 0 ל-2 בחזקת n.\nנתון שכל מספר במערך הוא כפולה של ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש. הציעו אלגוריתם למיון המערך.\n', 'נחלק כל מספר ב-(ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש). כעת איברי המערך בתחום [0, n^3] וניתן למיינם באמצעות O(n) .radix sort.'],
    ['נדרש מבנה נתונים התומך בפעולות הבאות על איברים המכילים שני שדות – id, amount. בכל רגע נתון מספר האיברים במבנה אינו עולה על N.\n1. (Add(i,x מגדילה ב-x ערכו של שדה amount של האיבר (היחיד) בעל id=i אם קיים. אחרת, אם לא קיים איבר כזה, מוסיף איבר עם id=i, amount=x (לא נתון מצביע לאיבר)\n2. ()whoIsMax מחזירה את ה-id עבורו שדה ה-amount מקסימלי (אם קיים יותר מאחד כזה, מחזירה אחד מהם)\n3. (Reduce (i,y מפחיתה y מה-amount של האיבר בעל id=i (לא נתון מצביע לאיבר)\n\nנניח כי כל ה-id נמצאים בטווח [1,3n].\nתארו מבנה דטרמיניסטי התומך בפעולות 1-2 בזמן (1)O במקרה הגרוע ביותר (אין צורך לממש את פעולה 3).', 'נקצה מערך בגודל 3n. בכל קריאה ל-Add נעדכן התא המתאים במערך ונבדוק אם הוא המקסימום החדש על ידי השוואה לנוכחי. whoIsMax יחזיר את המקסימום שיישמר תמיד בשדה עזר.'],
    ['האם ניתן לממש עץ AVL כך שפעולת ה-insert תיקח במקרה הגרוע ביותר (1)O ופעולת ה-delete תיקח (O(n, כאשר n מספר האיברים בעץ?', 'לא ניתן. ניקח קבוצה כללית של מספרים בגודל n, נכניסם לעץ ונקבל אותם ממוינים על ידי in order walk ב-(O(n.'],
    ['האם ניתן לממש עץ חיפוש כלשהו כך שפעולת ה-insert תיקח במקרה הגרוע ביותר (1)O ופעולת ה-delete תיקח (O(n, כאשר n מספר האיברים בעץ?', 'לא ניתן. ניקח קבוצה כללית של מספרים בגודל n, נכניסם לעץ ונקבל אותם ממוינים על ידי in order walk ב-(O(n.'],
    ['האם ניתן לממש עץ AVL כך שנוסיף לו פעולה החזר את האיבר המינימלי שגדול שווה לממוצע האיברים בזמן (1)O מבלי לפגוע בזמן הריצה של שאר הפעולות?', 'נחזיק מצביע עזר שיתוחזק בכל פעולת insert,delete ויצביע לאיבר הרלוונטי. ידרוש עדכון של הממוצע בכל שלב וחיפוש האיבר המתאים, מה שנכנס בזמן הריצה של (O(logn.'],
    ['בונים טבלת hashing בגודל m בשיטת  ה-chaining. פונקצית ה-hash נבחרת באקראי ממשפחה אוניברסלית של פונקציות hash. לטבלה הוכנסו כבר n איברים שונים. מבצעים עתה חיפוש איבר x שנמצא כבר בטבלה. ספקו חסם טוב ככל האפשר (לא אסימפטוטי) על תוחלת מספר האיברים ברשימה שבה נמצא .x', '1+(n-1)/m'],
    ['בונים טבלת  hashing בגודל m בשיטת ה-open addressing (כלומר, כל האיברים נמצאים בטבלת ה-hashing ללא שימוש במצביעים). משתמשים בפונקציית hash מקרית לחלוטין מהצורה h(k,i), כאשר k הוא המפתח שאותו רוצים להכניס לטבלה ו-i הוא מספר הניסיון. (זאת שיטת ה-uniform probing. ערך המוחזר מקריאה ל-h(k,i) הוא שלם המוגרל יוניפורמית בין 2 ל-(m-1), בלתי-תלוי בהגרלות שבקריאות קודמות). לטבלה הוכנסו כבר n איברים שונים. מבצעים עתה חיפוש על איבר שאינו נמצא בטבלה. מה תוחלת מספר תאי הטבלה שנבדקים במהלך החיפוש? ספקו תשובה (לא אסימפטוטית) הדוקה ככל האפשר.', '1/(1-n/m)'],
    ['בונים טבלת  hashing בגודל m בשיטת ה-linear probing. מפתחות האיברים שמוכנסים לטבלה נלקחים מהקבוצה {0,1,…2m-1}. משתמשים בפונקצית ה-hash הבאה: h(k)=⌊k\\2⌋. מכניסים לטבלה את האיברים 1,2,…m בסדר עולה. כמה זמן לוקחת הכנסת כל האיברים לטבלה תוך שימוש באלגוריתם ההכנסה הסטנדרטי? ספקו חסם אסימפטוטי.', 'זמן ריבועי'],
    ['תהא  U={0,1,…u}. הניחו שכל איבר של U ניתן לייצוג במילת מחשב אחת. נתונה תת-קבוצה D⊆U בגודל n. תארו אלגוריתם הסתברותי יעיל ככל האפשר שבונה פונקציה h:U→{0,1,…100n} שהיא חד-חד ערכית על  D. (כלומר לכל x,y∈D מתקיים h(x)!=h(y)). כמות הזיכרון הדרושה לייצוג הפונקציה h צריכה להיות  O(n). חישוב h(x), בהינתן x∈D צריך לקחת O(1) זמן במקרה הגרוע ביותר.', 'perfect hash'],
    ['נגדיר מערך זיג-זג, עבורו קיימים n ≤ j ≤ i ≤ 1 כלשהם כך שכל האיברים במערך בין 1 ל i בסדר עולה, כל האיברים בין i ל j בסדר יורד, וכל האיברים בין j ל n בסדר עולה. נקרא ל-i איבר הפסגה ול-j איבר העמק.\nספקו חסם עליון ותחתון לבעיה - קלט: מערך. פלט: מחזיר TRUE אם"ם המערך הוא מערך זיגזג.\n', 'חסם עליון ותחתון n.\n'],
    ['נתונים n קטעים על הישר (כלומר הקלט הוא n זוגות (x,y) של נקודות התחלה וסיום). קטע יקרא "מרכזי" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו אלגוריתם שמחזיר את מספר הקטעים המרכזיים, בזמן ריצה W.C. הטוב ביותר שתוכלו, ונתחו את זמן הריצה שלו.', 'אפשר להריץ  select על n/4 ב-x ו-3n/4 ב-y, ולפי זה לזהות קטעים מרכזיים. זמן ריצה לינארי במספר הקטעים.'],
]