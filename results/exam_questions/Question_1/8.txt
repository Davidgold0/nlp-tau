Question: A pair of values in an array are called consecutive if they are different and, after sorting, they appear in adjacent positions in the array.  

Given an array of natural numbers of size \( n \), propose an algorithm (with the best worst-case complexity) that checks whether there exists a pair of consecutive values whose total occurrences together are at least \( k \)  
(that is, the number of times a certain value appears plus the number of times its consecutive value appears is at least \( k \)).
3o-mini: We can solve the problem in essentially two steps:
 1. Count the frequency of each distinct number.
 2. Order the distinct values and check each adjacent pair.

Recall that a “consecutive” pair (by the problem’s definition) means that if you sort the distinct keys (that is, the set of numbers appearing in the array), then any two numbers that appear next to each other in that sorted order form a consecutive pair (regardless of whether their numerical difference is 1).

One acceptable algorithm is as follows:

Step 1. Build a Frequency Table
 • Create an empty dictionary (or hash table) called frequency.
 • Loop through the array (of size n). For every number x, increment frequency[x].
 • This takes O(n) time.

Step 2. Sort the Distinct Values and Check Adjacent Pairs
 • Let keys be the list of keys in the frequency table.
 • Sort keys. In the worst case (if the keys cannot be sorted via counting sort, e.g., if the natural numbers can be arbitrarily large) this sorting takes O(u log u) time, where u is the number of distinct numbers. Since u ≤ n, this is O(n log n) worst-case.
 • Now, for each adjacent pair (keys[i], keys[i+1]) in the sorted list, compute:
   total = frequency[keys[i]] + frequency[keys[i+1]]
   If total ≥ k, then output “Yes” (or return true) and stop.
 • If no such pair is found, output “No” (or return false).

Pseudocode:

-------------------------------------------------------
function hasConsecutivePair(array, n, k):
    // Step 1: Count frequencies
    frequency = {}   // dictionary
    for i = 0 to n-1:
        x = array[i]
        if x in frequency:
            frequency[x] = frequency[x] + 1
        else:
            frequency[x] = 1

    // Step 2: Sort the distinct keys
    keys = list of keys in frequency
    sort(keys)   // O(u log u) which is O(n log n) in worst-case

    // Check adjacent pairs:
    for i = 0 to length(keys)-2:
        if frequency[keys[i]] + frequency[keys[i+1]] >= k:
            return True

    return False
-------------------------------------------------------

Complexity Analysis:
 • Building the frequency table: O(n)
 • Sorting the keys: O(n log n) in the worst case.
 • Scanning through the sorted keys: O(n)
Thus, the overall worst-case time complexity is O(n log n). 

A Note on Best Cases:
If the natural numbers are known to be in a small range, you could use counting sort (or a similar bucketing approach), potentially reducing the sorting step to O(n) and thus achieving an overall O(n) time algorithm.

This algorithm efficiently checks whether there exists a pair of consecutive (in the sorted order of distinct values) numbers whose combined frequency is at least k.