"Question: **In this question, we will discuss the Quicksort algorithm. Throughout the question, we assume the input is an array of length \( n \), and we are interested only in arrays where all elements are distinct. As is known, each sorting algorithm has an associated binary tree that represents the comparisons the algorithm performs for all possible inputs.**"
"We are interested in the Quicksort algorithm where the pivot element is always chosen to be the first element of the segment of the array the algorithm is working on (rather than being chosen randomly), and we will focus on the comparison tree corresponding to this algorithm."
**(A) What is the smallest depth of a leaf in this comparison tree as a function of \( n \)?**
3o-mini: We first explain the setup. Recall that any comparison‐based sorting algorithm can be modeled by a “decision tree” (or comparison tree) whose leaves represent the different outcomes (sorted orders) and whose depth (i.e. the number of comparisons made) depends on the particular input.
"Here we consider the version of Quicksort that always picks the first element of the array (or subarray) as the pivot. (Also, we assume that the input has n distinct elements.) For a given input permutation the algorithm will make a certain number of comparisons, and this number is exactly the depth of the leaf corresponding to that permutation in the comparison tree generated by the algorithm."
"The question is: What is the smallest possible depth of any leaf in this tree – that is, what is the smallest number of comparisons that this pivot‐rule version of Quicksort can ever use on an n‐element input?"
"When we “count comparisons” in Quicksort, note that at each recursive call on an array (or subarray) of length k the pivot (which is the first element) is compared to each of the other k − 1 elements in order to partition the array. In addition, after partitioning the algorithm recurses on the two resulting subarrays."
"Thus, if we denote by T(n) the number of comparisons made on an n–element array in the best possible case (i.e. corresponding to the shallowest leaf), we see that a “good” (best‐case) input is one for which at every recursive call the pivot splits the array as evenly as possible. (Note that since the pivot is forced to be the first element, the only inputs that lead to such even splits are the specific permutations in which the first entry is the median of the array, the first entry in the left subarray is the median of that subarray, and so on.)"
"For example, in a “balanced” partition the first element (pivot) is the median. Then there are roughly (n − 1)/2 elements in each partition. In this ideal situation the recurrence for the best‐case cost (i.e. the depth of the leaf in the tree for that input) is"
  T(n) = (n − 1) + T(⌊(n − 1)/2⌋) + T(⌈(n − 1)/2⌉)
with the base cases T(0) = T(1) = 0 (since no comparisons are needed for an array of length 0 or 1).
"It turns out that when the splits are as balanced as possible, the solution to this recurrence grows as Θ(n log n). In fact, if one works out the recurrence in the particularly clean case when n is a power of 2 (so that the splits are exactly equal at each level), one obtains"
  T(n) = n log₂ n − n + 1.
"Thus, as a function of n the smallest depth of a leaf in the comparison tree for this version of Quicksort is approximately n log n (with base 2 logarithms) – that is, asymptotically on the order of n log n."
To summarize:
• The best‐case input for our fixed–pivot Quicksort is one in which every pivot is the median of its subarray.
• For such an input the number of comparisons satisfies
"  T(n) ≃ (n − 1) + 2T(n/2),"
which (when solved exactly for n = 2^k) gives
  T(n) = n log₂ n − n + 1.
"• Therefore, the smallest depth of a leaf in the comparison tree is Θ(n log n)."
"So the answer is: The minimal number of comparisons performed (i.e. the smallest depth of a leaf in the comparison tree) is roughly n log₂ n − n + 1 (when n is a power of 2), so in general it is Θ(n log n)."
